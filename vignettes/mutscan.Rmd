---
title: "mutscan"
author: "Charlotte Soneson and Michael Stadler"
date: "`r BiocStyle::doc_date()`"
package: "`r BiocStyle::pkg_ver('mutscan')`"
output: 
  BiocStyle::html_document:
    toc_float: true
vignette: >
  %\VignetteIndexEntry{mutscan}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction

`mutscan` provides functionality for processing and visualization of Deep
Mutational Scanning and other similar data, starting from (paired-end) 
FASTQ files. Both TRANS experiments (considering pairs of proteins) and 
CIS experiments (studying a single protein) can be accommodated.

```{r setup, message = FALSE}
library(SummarizedExperiment)
library(mutscan)
```

# Reading example data

The `mutscan` package contains several small example FASTQ files 
representing different types of experiments:

```{r readTrans}
datadir <- system.file("extdata", package = "mutscan")
dir(datadir)
```

- `transInput_{1,2}.fastq.gz`, `transOutput_{1,2}.fastq.gz` - data from TRANS
experiment in [@Diss2018]. The forward and reverse reads correspond to the
mutated _FOS_ and _JUN_ sequences, respectively. Each read consists of a UMI
sequence, followed by a constant sequence and the variable region.
- `cisInput_{1,2}.fastq.gz`, `cisOutput_{1,2}.fastq.gz` - data from CIS
experiment in [@Diss2018]. The forward and reverse reads both correspond to the
mutated _FOS_ sequence. Each read consists of a UMI sequence, followed by a
constant sequence and the variable region.
- `GSE102901_cis_se.rds` - a `SummarizedExperiment` object obtained by
processing the full CIS data from [@Diss2018].
- `leujunt0_{1,2}.fastq.gz` - unpublished data; the forward read corresponds to
an unmutated sequence of one of 46 leucine zipper sequences, and the reverse
read corresponds to mutated _JUN_ sequences. Each read contains a
(frame-shifted) primer sequence, followed by the variable region.

# Processing Deep Mutational Scanning data

The main function for processing the Deep Mutational Scanning FASTQ files is
`digestFastqs`. This function requires the specification of paths to compressed
FASTQ file(s) and the composition of the reads in these files. The composition 
is specified by the user, and is given in the form of a character string 
indicating the parts constituting the respective read, and an integer vector 
specifying the lengths of the individual parts. For example, a read with the 
following composition:

[1 skipped nt] - [10 nt UMI] - [18 nt constant sequence] - [96 nt variable region] 

would be represented by an elements string `"SUCV"`, and an element length
vector `c(1, 10, 18, 96)`. 

The package can also accommodate designs with primer sequences. In this situation, 
the primer acts as an 'anchor', and the read composition before and after the 
primer is specified. For example, a read with the following composition:

[unknown sequence] - [10 nt primer] - [variable region, constituting the remainder of the read]

would be represented by an elements string `"SPV"`, and an element length 
vector `c(-1, 10, -1)`, where the -1 indicates that the corresponding read part
consists of the remaining part of the read, not accounted for by any of the other 
specified parts. In addition, the sequence of the primer must be specified, and 
any read where the primer is not present will be discarded. 

The forward and reverse reads can have different compositions. The user can 
also specify whether the variable parts of the forward and/or
reverse reads should be reverse complemented before processing, and whether the
variable regions of the forward and reverse reads should be merged into a single
consensus sequence.

In addition to reading the FASTQ files, the `digestFastqs` function will perform
a series of filtering steps, in the following order:

* Search for perfect matches to forward/reverse adapter sequences, filter out
the read pair if a match is found in either the forward or reverse read.
* Search for perfect matches to forward/reverse primer sequences, filter out the
read pair if not both are found.
* Filter out reads whose length is not compatible with the indicated composition.
* If forward and reverse variable regions should be merged, filter out read
pairs where no valid overlap could be found.
* Filter out read pair if the average quality in the variable region is below
`avePhredMin` in either the forward or reverse read (or the consensus sequence
if they are merged).
* Filter out read pair if the number of Ns in the variable region exceeds
`variableNMax`.
* Filter out read pair if the number of Ns in the combined forward and reverse
UMI sequence exceeds `umiNMax`.
* Filter out read pair if any mutated base has a quality below
`mutatedPhredMin`.
* Filter out read pair if the number of mutated codons exceeds
`nbrMutatedCodonsMax`.
* Filter out read pair if any of the mutated codons match any of the
codons encoded by `forbiddenMutatedCodons`.

# Reading TRANS data

Here, we illustrate the processing of the provided TRANS experiment example
data. We filter out reads with any adapter match, an average phred quality below
20, any Ns in the UMI or variable sequence, more than one mutated codon, or a
mutated codon ending with A or T (represented by the `NNW` value of the
`forbiddenMutatedCodon` argument).

```{r}
transInput <- digestFastqs(fastqForward = file.path(datadir, "transInput_1.fastq.gz"),
                           fastqReverse = file.path(datadir, "transInput_2.fastq.gz"),
                           mergeForwardReverse = FALSE, 
                           minOverlap = 0, maxOverlap = 0, 
                           maxFracMismatchOverlap = 1, greedyOverlap = TRUE, 
                           revComplForward = FALSE, revComplReverse = FALSE,
                           elementsForward = "SUCV", elementsReverse = "SUCV",
                           elementLengthsForward = c(1, 10, 18, 96),
                           elementLengthsReverse = c(1, 8, 20, 96),
                           constantForward = "AACCGGAGGAGGGAGCTG",
                           constantReverse = "GAAAAAGGAAGCTGGAGAGA", 
                           adapterForward = "GGAAGAGCACACGTC", 
                           adapterReverse = "GGAAGAGCGTCGTGT", 
                           primerForward = "", primerReverse = "",
                           avePhredMinForward = 20, avePhredMinReverse = 20,
                           variableNMaxForward = 0, variableNMaxReverse = 0, umiNMax = 0,
                           wildTypeForward = "ACTGATACACTCCAAGCGGAGACAGACCAACTAGAAGATGAGAAGTCTGCTTTGCAGACCGAGATTGCCAACCTGCTGAAGGAGAAGGAAAAACTA", 
                           wildTypeReverse = "ATCGCCCGGCTGGAGGAAAAAGTGAAAACCTTGAAAGCTCAGAACTCGGAGCTGGCGTCCACGGCCAACATGCTCAGGGAACAGGTGGCACAGCTT", 
                           nbrMutatedCodonsMaxForward = 1, nbrMutatedCodonsMaxReverse = 1,
                           forbiddenMutatedCodonsForward = "NNW", forbiddenMutatedCodonsReverse = "NNW",
                           mutNameDelimiter = ".", 
                           variableCollapseMaxDist = 0.0,
                           variableCollapseMinReads = 0,
                           umiCollapseMaxDist = 0.0,
                           maxNReads = -1, verbose = FALSE)
```

The `digestFastqs` function returns a list with four elements. The `parameters`
list record all parameter values used during the processing, as well as the
package version and time of processing.

```{r}
transInput$parameters
```

The `filterSummary` data.frame contains a summary of the number of reads
filtered out in each step. Note that for any given filtering step, only the
reads retained by the previous filters are considered. The numbers in the filter
column names indicate the order of the filters.

```{r}
transInput$filterSummary
```

The `summaryTable` provides the number of reads and unique UMIs observed for
each variable sequence pair. In addition, it contains a column `mutNames`, which
provides a shorthand notation for each mutant. The format of the values in this
column is a combination of `{f/r}.xx.NNN` (separated by `_`), where `f/r` refers
to the forward/reverse read, `xx` indicates the mutated codon number, and `NNN`
gives the observed sequence for the mutated codon.

```{r}
head(transInput$summaryTable)
```

Finally, the `errorStatistics` data.frame lists the number of matching and
mismatching bases in the constant sequences, stratified by the phred quality
score (from 0 to 99).

```{r}
transInput$errorStatistics[rowSums(transInput$errorStatistics[, -1]) != 0, ]
```

The `errorStatistics` output can be used to estimate the sequencing error rate:

```{r errStats}
(propErrorsConstantF <- sum(transInput$errorStatistics$nbrMismatchForward) /
   (nchar(transInput$parameters$constantForward) * transInput$filterSummary$nbrRetained))
(propErrorsConstantR <- sum(transInput$errorStatistics$nbrMismatchReverse) /
   (nchar(transInput$parameters$constantReverse) * transInput$filterSummary$nbrRetained))
```

# Reading CIS data

Here, we illustrate the processing of the provided CIS experiment example data.
As for the TRANS data, we filter out reads with any adapter match, an average
phred quality below 20, any Ns in the UMI or variable sequence, more than one
mutated codon, or a mutated codon ending with A or T (represented by the `NNW`
value of the `forbiddenMutatedCodon` argument). Note that only one wild type
sequence is provided (the `wildTypeReverse` argument will be ignored if
provided).

```{r}
cisInput <- digestFastqs(fastqForward = file.path(datadir, "cisInput_1.fastq.gz"),
                         fastqReverse = file.path(datadir, "cisInput_2.fastq.gz"),
                         mergeForwardReverse = TRUE, 
                         minOverlap = 0, maxOverlap = 0, 
                         maxFracMismatchOverlap = 1, greedyOverlap = TRUE, 
                         revComplForward = FALSE, revComplReverse = TRUE,
                         elementsForward = "SUCV", elementsReverse = "SUCVS",
                         elementLengthsForward = c(1, 10, 18, 96),
                         elementLengthsReverse = c(1, 7, 17, 96, -1),
                         constantForward = "AACCGGAGGAGGGAGCTG",
                         constantReverse = "GAGTTCATCCTGGCAGC", 
                         adapterForward = "GGAAGAGCACACGTC", 
                         adapterReverse = "GGAAGAGCGTCGTGT", 
                         primerForward = "", primerReverse = "",
                         avePhredMinForward = 20, avePhredMinReverse = 20,
                         variableNMaxForward = 0, variableNMaxReverse = 0, umiNMax = 0,
                         wildTypeForward = "ACTGATACACTCCAAGCGGAGACAGACCAACTAGAAGATGAGAAGTCTGCTTTGCAGACCGAGATTGCCAACCTGCTGAAGGAGAAGGAAAAACTA", 
                         wildTypeReverse = "", 
                         nbrMutatedCodonsMaxForward = 1, nbrMutatedCodonsMaxReverse = 1, 
                         forbiddenMutatedCodonsForward = "NNW", forbiddenMutatedCodonsReverse = "NNW",
                         mutNameDelimiter = ".", 
                         variableCollapseMaxDist = 0.0,
                         variableCollapseMinReads = 0,
                         umiCollapseMaxDist = 0.0,
                         maxNReads = -1, verbose = TRUE)
```

```{r}
cisInput$parameters
cisInput$filterSummary
cisInput$errorStatistics[rowSums(cisInput$errorStatistics[, -1]) != 0, ]
```

The `summaryTable` now provides the number of reads and unique UMIs observed for
each variable sequence, and all values in the `mutNames` column will start with `f`.

```{r}
head(cisInput$summaryTable)
```

# Reading TRANS data with primers

Here, we illustrate the processing of the provided example data, where the first
read corresponds to one of 46 leucine zipper sequences, and the second read is a
mutated _JUN_ sequence. We first need to define the possible sequences for the
forward read. If multiple wild type sequences are provided, `mutscan` will find
the most similar one for each read.

```{r}
leu <- c(ATF2 = "GATCCTGATGAAAAAAGGAGAAAGTTTTTAGAGCGAAATAGAGCAGCAGCTTCAAGATGCCGACAAAAAAGGAAAGTCTGGGTTCAGTCTTTAGAGAAGAAAGCTGAAGACTTGAGTTCATTAAATGGTCAGCTGCAGAGTGAAGTCACCCTGCTGAGAAATGAAGTGGCACAGCTGAAACAGCTTCTTCTGGCT",
         ATF7 = "GATCCAGATGAGCGACGGCAGCGCTTTCTGGAGCGCAACCGGGCTGCAGCCTCCCGCTGCCGCCAAAAGCGAAAGCTGTGGGTGTCCTCCCTAGAGAAGAAGGCCGAAGAACTCACTTCTCAGAACATTCAGCTGAGTAATGAAGTCACATTACTACGCAATGAGGTGGCCCAGTTGAAACAGCTACTGTTAGCT",
         CREB5 = "GATCCGGACGAGAGGCGGCGGAAATTTCTGGAACGGAACCGGGCAGCTGCCACCCGCTGCAGACAGAAGAGGAAGGTCTGGGTGATGTCATTGGAAAAGAAAGCAGAAGAACTCACCCAGACAAACATGCAGCTTCAGAATGAAGTGTCTATGTTGAAAAATGAGGTGGCCCAGCTGAAACAGTTGTTGTTAACA",
         ATF3 = "GAAGAAGATGAAAGGAAAAAGAGGCGACGAGAAAGAAATAAGATTGCAGCTGCAAAGTGCCGAAACAAGAAGAAGGAGAAGACGGAGTGCCTGCAGAAAGAGTCGGAGAAGCTGGAAAGTGTGAATGCTGAACTGAAGGCTCAGATTGAGGAGCTCAAGAACGAGAAGCAGCATTTGATATACATGCTCAACCTT",
         JDP2 = "GAGGAAGAGGAGCGAAGGAAAAGGCGCCGGGAGAAGAACAAAGTCGCAGCAGCCCGATGCCGGAACAAGAAGAAGGAGCGCACGGAGTTTCTGCAGCGGGAATCCGAGCGGCTGGAACTCATGAACGCAGAGCTGAAGACCCAGATTGAGGAGCTGAAGCAGGAGCGGCAGCAGCTCATCCTGATGCTGAACCGA",
         ATF4 = "GAGAAACTGGATAAGAAGCTGAAAAAAATGGAGCAAAACAAGACAGCAGCCACTAGGTACCGCCAGAAGAAGAGGGCGGAGCAGGAGGCTCTTACTGGTGAGTGCAAAGAGCTGGAAAAGAAGAACGAGGCTCTAAAAGAGAGGGCGGATTCCCTGGCCAAGGAGATCCAGTACCTGAAAGATTTGATAGAAGAG",
         ATF5 = "ACCCGAGGGGACCGCAAGCAAAAGAAGAGAGACCAGAACAAGTCGGCGGCTCTGAGGTACCGCCAGCGGAAGCGGGCAGAGGGTGAGGCCCTGGAGGGCGAGTGCCAGGGGCTGGAGGCACGGAATCGCGAGCTGAAGGAACGGGCAGAGTCCGTGGAGCGCGAGATCCAGTACGTCAAGGACCTGCTCATCGAG",
         CREBZF = "AGTCCCCGGAAGGCGGCGGCGGCCGCTGCCCGCCTTAATCGACTGAAGAAGAAGGAGTACGTGATGGGGCTGGAGAGTCGAGTCCGGGGTCTGGCAGCCGAGAACCAGGAGCTGCGGGCCGAGAATCGGGAGCTGGGCAAACGCGTACAGGCACTGCAGGAGGAGAGTCGCTACCTACGGGCAGTCTTAGCCAAC",
         BATF2 = "CCCAAGGAGCAACAAAGGCAGCTGAAGAAGCAGAAGAACCGGGCAGCCGCCCAGCGAAGCCGGCAGAAGCACACAGACAAGGCAGACGCCCTGCACCAGCAGCACGAGTCTCTGGAAAAAGACAACCTCGCCCTGCGGAAGGAGATCCAGTCCCTGCAGGCCGAGCTGGCGTGGTGGAGCCGGACCCTGCACGTG",
         BATF3 = "GAGGATGATGACAGGAAGGTCCGAAGGAGAGAAAAAAACCGAGTTGCTGCTCAGAGAAGTCGGAAGAAGCAGACCCAGAAGGCTGACAAGCTCCATGAGGAATATGAGAGCCTGGAGCAAGAAAACACCATGCTGCGGAGAGAGATCGGGAAGCTGACAGAGGAGCTGAAGCACCTGACAGAGGCACTGAAGGAG",
         CEBPE = "AAAGATAGCCTTGAGTACCGGCTGAGGCGGGAGCGCAACAACATCGCCGTGCGCAAGAGCCGAGACAAGGCCAAGAGGCGCATTCTGGAGACGCAGCAGAAGGTGCTGGAGTACATGGCAGAGAACGAGCGCCTCCGCAGCCGCGTGGAGCAGCTCACCCAGGAGCTAGACACCCTCCGCAACCTCTTCCGCCAG",
         BACH1 = "CTGGATTGTATCCATGATATTCGAAGAAGAAGTAAAAACAGAATTGCTGCACAGCGCTGTCGCAAGAGAAAACTTGACTGTATACAGAATCTTGAATCAGAAATTGAGAAGCTGCAAAGTGAAAAGGAGAGCTTGTTGAAGGAAAGAGATCACATTTTGTCAACTCTGGGTGAGACAAAGCAGAACCTAACTGGA",
         BACH2 = "TTAGAGTTTATTCATGATGTCCGACGGCGCAGCAAGAACCGCATCGCGGCCCAGCGCTGCCGCAAAAGGAAACTGGACTGTATTCAGAATTTAGAATGTGAAATCCGCAAATTGGTGTGTGAGAAAGAGAAACTGTTGTCAGAGAGGAATCAACTGAAAGCATGCATGGGGGAACTGTTGGACAACTTCTCCTGC",
         NFE2L1 = "CTGAGCCTCATCCGAGACATCCGGCGCCGGGGCAAGAACAAGATGGCGGCGCAGAACTGCCGCAAGCGCAAGCTGGACACCATCCTGAATCTGGAGCGTGATGTGGAGGACCTGCAGCGTGACAAAGCCCGGCTGCTGCGGGAGAAAGTGGAGTTCCTGCGCTCCCTGCGACAGATGAAGCAGAAGGTCCAGAGC",
         NFE2 = "CTAGCGCTAGTCCGGGACATCCGACGACGGGGCAAAAACAAGGTGGCAGCCCAGAACTGCCGCAAGAGGAAGCTGGAAACCATTGTGCAGCTGGAGCGGGAGCTGGAGCGGCTGACCAATGAACGGGAGCGGCTTCTCAGGGCCCGCGGGGAGGCAGACCGGACCCTGGAGGTCATGCGCCAACAGCTGACAGAG",
         NFIL3 = "AAGAAAGATGCTATGTATTGGGAAAAAAGGCGGAAAAATAATGAAGCTGCCAAAAGATCTCGTGAGAAGCGTCGACTGAATGACCTGGTTTTAGAGAACAAACTAATTGCACTGGGAGAAGAAAACGCCACTTTAAAAGCTGAGCTGCTTTCACTAAAATTAAAGTTTGGTTTAATTAGCTCCACAGCATATGCT",
         FOS = "GAAGAAGAAGAGAAAAGGAGAATCCGAAGGGAAAGGAATAAGATGGCTGCAGCCAAATGCCGCAACCGGAGGAGGGAGCTGACTGATACACTCCAAGCGGAGACAGACCAACTAGAAGATGAGAAGTCTGCTTTGCAGACCGAGATTGCCAACCTGCTGAAGGAGAAGGAAAAACTAGAGTTCATCCTGGCAGCT",
         FOSB = "GAGGAAGAGGAGAAGCGAAGGGTGCGCCGGGAACGAAATAAACTAGCAGCAGCTAAATGCAGGAACCGGCGGAGGGAGCTGACCGACCGACTCCAGGCGGAGACAGATCAGTTGGAGGAAGAAAAAGCAGAGCTGGAGTCGGAGATCGCCGAGCTCCAAAAGGAGAAGGAACGTCTGGAGTTTGTGCTGGTGGCC",
         FOSL1 = "GAGGAAGAGGAGCGCCGCCGAGTAAGGCGCGAGCGGAACAAGCTGGCTGCGGCCAAGTGCAGGAACCGGAGGAAGGAACTGACCGACTTCCTGCAGGCGGAGACTGACAAACTGGAAGATGAGAAATCTGGGCTGCAGCGAGAGATTGAGGAGCTGCAGAAGCAGAAGGAGCGCCTAGAGCTGGTGCTGGAAGCC",
         FOSL2 = "GAAGAGGAGGAGAAGCGTCGCATCCGGCGGGAGAGGAACAAGCTGGCTGCAGCCAAGTGCCGGAACCGACGCCGGGAGCTGACAGAGAAGCTGCAGGCGGAGACAGAGGAGCTGGAGGAGGAGAAGTCAGGCCTGCAGAAGGAGATTGCTGAGCTGCAGAAGGAGAAGGAGAAGCTGGAGTTCATGTTGGTGGCT",
         MAFB = "GTGATCCGCCTGAAGCAGAAGCGGCGGACCCTGAAGAACCGGGGCTACGCCCAGTCTTGCAGGTATAAACGCGTCCAGCAGAAGCACCACCTGGAGAATGAGAAGACGCAGCTCATTCAGCAGGTGGAGCAGCTTAAGCAGGAGGTGTCCCGGCTGGCCCGCGAGAGAGACGCCTACAAGGTCAAGTGCGAGAAA",
         JUN = "CAGGAGCGGATCAAGGCGGAGAGGAAGCGCATGAGGAACCGCATCGCTGCCTCCAAGTGCCGAAAAAGGAAGCTGGAGAGAATCGCCCGGCTGGAGGAAAAAGTGAAAACCTTGAAAGCTCAGAACTCGGAGCTGGCGTCCACGGCCAACATGCTCAGGGAACAGGTGGCACAGCTTAAACAGAAAGTCATGAAC",
         JUNB = "CAAGAGCGCATCAAAGTGGAGCGCAAGCGGCTGCGGAACCGGCTGGCGGCCACCAAGTGCCGGAAGCGGAAGCTGGAGCGCATCGCGCGCCTGGAGGACAAGGTGAAGACGCTCAAGGCCGAGAACGCGGGGCTGTCGAGTACCGCCGGCCTCCTCCGGGAGCAGGTGGCCCAGCTCAAACAGAAGGTCATGACC",
         JUND = "CAGGAGCGCATCAAGGCGGAGCGCAAGCGGCTGCGCAACCGCATCGCCGCCTCCAAGTGCCGCAAGCGCAAGCTGGAGCGCATCTCGCGCCTGGAAGAGAAAGTGAAGACCCTCAAGAGTCAGAACACGGAGCTGGCGTCCACGGCGAGCCTGCTGCGCGAGCAGGTGGCGCAGCTCAAGCAGAAAGTCCTCAGC",
         CREB3 = "GAACAAATTCTGAAACGTGTGCGGAGGAAGATTCGAAATAAAAGATCTGCTCAAGAGAGCCGCAGGAAAAAGAAGGTGTATGTTGGGGGTTTAGAGAGCAGGGTCTTGAAATACACAGCCCAGAATATGGAGCTTCAGAACAAAGTACAGCTTCTGGAGGAACAGAATTTGTCCCTTCTAGATCAACTGAGGAAA",
         HLF = "CTGAAGGATGACAAGTACTGGGCAAGGCGCAGAAAGAACAACATGGCAGCCAAGCGCTCCCGCGACGCCCGGAGGCTGAAAGAGAACCAGATCGCCATCCGGGCCTCGTTCCTGGAGAAGGAGAACTCGGCCCTCCGCCAGGAGGTGGCTGACTTGAGGAAGGAGCTGGGCAAATGCAAGAACATACTTGCCAAG",
         MAFG = "ATCGTCCAGCTGAAGCAGCGCCGGCGCACGCTCAAGAACCGCGGCTACGCTGCCAGCTGCCGCGTGAAGCGGGTGACGCAGAAGGAGGAGCTGGAGAAGCAGAAGGCGGAGCTGCAGCAGGAGGTGGAGAAGCTGGCCTCAGAGAACGCCAGCATGAAGCTGGAGCTCGACGCGCTGCGCTCCAAGTACGAGGCG",
         MAFK = "GTGACCCGCCTGAAGCAGCGTCGGCGCACACTCAAGAACCGCGGCTACGCGGCCAGCTGCCGCATCAAGCGGGTGACGCAGAAGGAGGAGCTGGAGCGGCAGCGCGTGGAGCTGCAGCAGGAGGTGGAGAAGCTGGCGCGTGAGAACAGCAGCATGCGGCTGGAGCTGGACGCCCTGCGCTCCAAGTACGAGGCG",
         XBP1 = "AGCCCCGAGGAGAAGGCGCTGAGGAGGAAACTGAAAAACAGAGTAGCAGCTCAGACTGCCAGAGATCGAAAGAAGGCTCGAATGAGTGAGCTGGAACAGCAAGTGGTAGATTTAGAAGAAGAGAACCAAAAACTTTTGCTAGAAAATCAGCTTTTACGAGAGAAAACTCATGGCCTTGTAGTTGAGAACCAGGAG",
         ATF6 = "ATTGCTGTGCTAAGGAGACAGCAACGTATGATAAAAAATCGAGAATCCGCTTGTCAGTCTCGCAAGAAGAAGAAAGAATATATGCTAGGGTTAGAGGCGAGATTAAAGGCTGCCCTCTCAGAAAACGAGCAACTGAAGAAAGAAAATGGAACACTGAAGCGGCAGCTGGATGAAGTTGTGTCAGAGAACCAGAGG",
         ATF6B = "GCAAAGCTGCTGAAGCGGCAGCAGCGAATGATCAAGAACCGGGAGTCAGCCTGCCAGTCCCGGAGAAAGAAGAAAGAGTATCTGCAGGGACTGGAGGCTCGGCTGCAAGCAGTACTGGCTGACAACCAGCAGCTCCGCCGAGAGAATGCTGCCCTCCGGCGGCGGCTGGAGGCCCTGCTGGCTGAAAACAGCGAG",
         CEBPA = "AAGAACAGCAACGAGTACCGGGTGCGGCGCGAGCGCAACAACATCGCGGTGCGCAAGAGCCGCGACAAGGCCAAGCAGCGCAACGTGGAGACGCAGCAGAAGGTGCTGGAGCTGACCAGTGACAATGACCGCCTGCGCAAGCGGGTGGAACAGCTGAGCCGCGAACTGGACACGCTGCGGGGCATCTTCCGCCAG",
         CEBPB = "AAGCACAGCGACGAGTACAAGATCCGGCGCGAGCGCAACAACATCGCCGTGCGCAAGAGCCGCGACAAGGCCAAGATGCGCAACCTGGAGACGCAGCACAAGGTCCTGGAGCTCACGGCCGAGAACGAGCGGCTGCAGAAGAAGGTGGAGCAGCTGTCGCGCGAGCTCAGCACCCTGCGGAACTTGTTCAAGCAG",
         CEBPD = "CGCGGCAGCCCCGAGTACCGGCAGCGGCGCGAGCGCAACAACATCGCCGTGCGCAAGAGCCGCGACAAGGCCAAGCGGCGCAACCAGGAGATGCAGCAGAAGTTGGTGGAGCTGTCGGCTGAGAACGAGAAGCTGCACCAGCGCGTGGAGCAGCTCACGCGGGACCTGGCCGGCCTCCGGCAGTTCTTCAAGCAG",
         CEBPG = "CGAAACAGTGACGAGTATCGGCAACGCCGAGAGAGGAACAACATGGCTGTGAAAAAGAGCCGGTTGAAAAGCAAGCAGAAAGCACAAGACACACTGCAGAGAGTCAATCAGCTCAAAGAAGAGAATGAACGGTTGGAAGCAAAAATCAAATTGCTGACCAAGGAATTAAGTGTACTCAAAGATTTGTTTCTTGAG",
         CREB1 = "GAAGCAGCACGAAAGAGAGAGGTCCGTCTAATGAAGAACAGGGAAGCAGCTCGAGAGTGTCGTAGAAAGAAGAAAGAATATGTGAAATGTTTAGAAAACAGAGTGGCAGTGCTTGAAAATCAAAACAAGACATTGATTGAGGAGCTAAAAGCACTTAAGGACCTTTACTGCCACAAATCAGAT",
         CREB3L1 = "GAGAAGGCCTTGAAGAGAGTCCGGAGGAAAATCAAGAACAAGATCTCAGCCCAGGAGAGCCGTCGTAAGAAGAAGGAGTATGTGGAGTGTCTAGAAAAGAAGGTGGAGACATTTACATCTGAGAACAATGAACTGTGGAAGAAGGTGGAGACCCTGGAGAATGCCAACAGGACCCTGCTCCAGCAGCTGCAGAAA",
         CREB3L2 = "GAGAAGGCCCTGAAGAAAATTCGGAGGAAGATCAAGAATAAGATTTCTGCTCAGGAAAGTAGGAGAAAGAAGAAAGAATACATGGACAGCCTGGAGAAAAAAGTGGAGTCTTGTTCAACTGAGAACTTGGAGCTTCGGAAGAAGGTAGAGGTTCTAGAGAACACTAATAGGACTCTCCTTCAGCAACTCCAGAAG",
         CREB3L3 = "GAGCGAGTGCTGAAAAAAATCCGCCGGAAAATCCGGAACAAGCAGTCGGCGCAAGAAAGCAGGAAGAAGAAGAAGGAATATATCGATGGCCTGGAGACTCGGATGTCAGCTTGCACTGCTCAGAATCAGGAGTTACAGAGGAAAGTCTTGCATCTCGAGAAGCAAAACCTGTCCCTCTTGGAGCAACTGAAGAAA",
         CREB3L4 = "GAGAGGGTCCTCAAGAAGGTCAGGAGGAAAATCCGTAACAAGCAGTCAGCTCAGGACAGTCGGCGGCGGAAGAAGGAGTACATTGATGGGCTGGAGAGCAGGGTGGCAGCCTGTTCTGCACAGAACCAAGAATTACAGAAAAAAGTCCAGGAGCTGGAGAGGCACAACATCTCCTTGGTAGCTCAGCTCCGCCAG",
         CREBL2 = "CCAGCCAAAATTGACTTGAAAGCAAAACTTGAGAGGAGCCGGCAGAGTGCAAGAGAATGCCGAGCCCGAAAAAAGCTGAGATATCAGTATTTGGAAGAGTTGGTATCCAGTCGAGAAAGAGCTATATGTGCCCTCAGAGAGGAACTGGAAATGTACAAGCAGTGGTGCATGGCAATGGACCAAGGAAAAATCCCT",
         CREBRF = "CCCTTAACAGCCCGACCAAGGTCAAGGAAGGAAAAAAATAAGCTGGCTTCCAGAGCTTGTCGGTTAAAGAAGAAAGCCCAGTATGAAGCTAATAAAGTGAAATTATGGGGCCTCAACACAGAATATGATAATTTATTGTTTGTAATCAACTCCATCAAGCAAGAGATTGTAAACCGGGTACAGAATCCAAGAGAT",
         DBP = "CAGAAGGATGAGAAATACTGGAGCCGGCGGTACAAGAACAACGAGGCAGCCAAGCGGTCCCGTGACGCCCGGCGGCTCAAGGAGAACCAGATATCGGTGCGGGCGGCCTTCCTGGAGAAGGAGAACGCCCTGCTGCGGCAGGAAGTTGTGGCCGTGCGCCAGGAGCTGTCCCACTACCGCGCCGTGCTGTCCCGA",
         NFE2L2 = "CTTGCATTAATTCGGGATATACGTAGGAGGGGTAAGAATAAAGTGGCTGCTCAGAATTGCAGAAAAAGAAAACTGGAAAATATAGTAGAACTAGAGCAAGATTTAGATCATTTGAAAGATGAAAAAGAAAAATTGCTCAAAGAAAAAGGAGAAAATGACAAAAGCCTTCACCTACTGAAAAAACAACTCAGCACC",
         NFE2L3 = "GTCTCACTTATCCGTGACATCAGACGAAGAGGGAAAAATAAAGTTGCTGCGCAGAACTGTCGTAAACGCAAATTGGACATAATTTTGAATTTAGAAGATGATGTATGTAACTTGCAAGCAAAGAAGGAAACTCTTAAGAGAGAGCAAGCACAATGTAACAAAGCTATTAACATAATGAAACAGAAACTGCATGAC",
         TEF = "CAGAAGGATGAAAAGTACTGGACAAGACGCAAGAAGAACAACGTGGCAGCTAAACGGTCACGGGATGCCCGGCGCCTGAAAGAGAATCAGATCACCATCCGGGCAGCCTTCCTGGAGAAGGAGAACACAGCCCTGCGGACGGAGGTGGCCGAGCTACGCAAGGAGGTGGGCAAGTGCAAGACCATCGTGTCCAAG"
)
```

Next we process the data, not allowing any mismatches in the forward read, but 1
mismatching codon in the reverse read. Now, we assume that the variable sequence
starts immediately after the provided primers, and hence we don't specify any
UMI/constant sequence lengths. For the forward read, the variable region is
taken to be the remainder of the read (after the primer), whereas for the
reverse read, we specify the variable sequence length to 96.

```{r}
leujunt0 <- digestFastqs(fastqForward = file.path(datadir, "leujunt0_1.fastq.gz"),
                         fastqReverse = file.path(datadir, "leujunt0_2.fastq.gz"),
                         mergeForwardReverse = FALSE, minOverlap = 0, maxOverlap = 0, 
                         maxFracMismatchOverlap = 1, greedyOverlap = TRUE, 
                         revComplForward = FALSE, revComplReverse = FALSE,
                         elementsForward = "SPV", elementsReverse = "SPVS",
                         elementLengthsForward = c(-1, 19, -1),
                         elementLengthsReverse = c(-1, 20, 96, -1),
                         constantForward = "", constantReverse = "", 
                         adapterForward = "", adapterReverse = "", 
                         primerForward = "GTCAGGTGGAGGCGGATCC", 
                         primerReverse = "GAAAAAGGAAGCTGGAGAGA",
                         avePhredMinForward = 20, avePhredMinReverse = 20, 
                         variableNMaxForward = 0, variableNMaxReverse = 0, umiNMax = 0,
                         wildTypeForward = leu, 
                         wildTypeReverse = "ATCGCCCGGCTGGAGGAAAAAGTGAAAACCTTGAAAGCTCAGAACTCGGAGCTGGCGTCCACGGCCAACATGCTCAGGGAACAGGTGGCACAGCTT", 
                         nbrMutatedCodonsMaxForward = 0, 
                         nbrMutatedCodonsMaxReverse = 1, 
                         forbiddenMutatedCodonsForward = "",
                         forbiddenMutatedCodonsReverse = "NNW",
                         mutatedPhredMinForward = 0.0, mutatedPhredMinReverse = 0.0,
                         mutNameDelimiter = ".", 
                         variableCollapseMaxDist = 0.0,
                         variableCollapseMinReads = 0,
                         umiCollapseMaxDist = 0.0,
                         maxNReads = -1, verbose = TRUE)
```

```{r}
leujunt0$parameters
leujunt0$filterSummary
```

```{r}
head(leujunt0$summaryTable)
```

# Combining samples

The `digestFastqs` function processes each sample (pair of FASTQ files)
separately. In order to prepare the data for statistical analysis, the
`summarizeExperiment` function takes a named list of outputs from
`digestFastqs`, and a data.frame with condition information, and generates a
\code{\link[SummarizedExperiment]{SummarizedExperiment}}, with an `assay`
containing either UMI or read counts.

```{r combine}
transOutput <- digestFastqs(fastqForward = file.path(datadir, "transOutput_1.fastq.gz"),
                            fastqReverse = file.path(datadir, "transOutput_2.fastq.gz"),
                            mergeForwardReverse = FALSE, 
                            minOverlap = 0, maxOverlap = 0, 
                            maxFracMismatchOverlap = 1, greedyOverlap = TRUE, 
                            revComplForward = FALSE, revComplReverse = FALSE,
                            elementsForward = "SUCV", elementsReverse = "SUCV",
                            elementLengthsForward = c(1, 10, 18, 96),
                            elementLengthsReverse = c(1, 8, 20, 96),
                            constantForward = "AACCGGAGGAGGGAGCTG",
                            constantReverse = "GAAAAAGGAAGCTGGAGAGA", 
                            adapterForward = "GGAAGAGCACACGTC", 
                            adapterReverse = "GGAAGAGCGTCGTGT", 
                            primerForward = "", primerReverse = "",
                            avePhredMinForward = 20, avePhredMinReverse = 20,
                            variableNMaxForward = 0, variableNMaxReverse = 0, umiNMax = 0,
                            wildTypeForward = "ACTGATACACTCCAAGCGGAGACAGACCAACTAGAAGATGAGAAGTCTGCTTTGCAGACCGAGATTGCCAACCTGCTGAAGGAGAAGGAAAAACTA", 
                            wildTypeReverse = "ATCGCCCGGCTGGAGGAAAAAGTGAAAACCTTGAAAGCTCAGAACTCGGAGCTGGCGTCCACGGCCAACATGCTCAGGGAACAGGTGGCACAGCTT", 
                            nbrMutatedCodonsMaxForward = 1, nbrMutatedCodonsMaxReverse = 1, 
                            forbiddenMutatedCodonsForward = "NNW", forbiddenMutatedCodonsReverse = "NNW",
                            mutNameDelimiter = ".", 
                            variableCollapseMaxDist = 0.0,
                            variableCollapseMinReads = 0,
                            umiCollapseMaxDist = 0.0,
                            maxNReads = -1, verbose = FALSE)
se <- summarizeExperiment(x = list(sample1 = transInput,
                                   sample2 = transOutput),
                          coldata = data.frame(Name = c("sample1", "sample2"),
                                               Condition = c("input", "output"),
                                               Replicate = c(1, 1),
                                               OD = c(0.05, 1.5)))
head(assay(se, "counts"))
Matrix::colSums(assay(se, "counts"))
head(rowData(se))
colData(se)
```

# Collapsing count matrix to amino acids

The \link{\code[SummarizedExperiment]{SummarizedExperiment}} object generated by
`summarizeExperiment()` contains one row for each observed variant
(combination). This can be further collapsed by replacing the mutated codon by
the corresponding amino acid, and aggregating the counts corresponding to the
same mutated amino acid (combination).

```{r}
se_collapsed <- collapseMutantsByAA(se)
head(assay(se_collapsed, "counts"))
Matrix::colSums(assay(se_collapsed, "counts"))
colData(se_collapsed)
```

# Calculating PPI scores

The function `calculatePPIScore` can be used to calculate PPI scores as in
[@Diss2018]. The function requires the user to specify a `pairingCol`,
containing the replicate ID for each sample; one or more `ODCols`, containing
the optical density for each sample, and a `comparison`, which is a character
vector of length 3 specifying the comparison to perform, of the form
(`groupColumn`, `numerator`, `denominator`). Here, `groupColumn` is the name of
the column in `colData(se)` that contains the grouping information, and
`numerator` and `denominator` specify the values of this column representing the
two groups to be compared.

Here, we illustrate the application of `calculatePPIScore` on a
SummarizedExperiment object generated as described above, for all the three CIS
replicates fro [@Diss2018].

```{r}
se <- readRDS(file.path(datadir, "GSE102901_cis_se.rds"))
se_collapsed <- collapseMutantsByAA(se)
ppis <- calculatePPIScore(se = se_collapsed, pairingCol = "Replicate", 
                          ODCols = c("OD1", "OD2"),
                          comparison = c("Condition", "cis_output", "cis_input"),
                          WTrows = "f.0.NA")
head(ppis[order(abs(rowMeans(ppis)), decreasing = TRUE), , drop = FALSE])
```

# Scoring mutations with `edgeR` or `limma`

As an alternative to the PPI scoring, `edgeR` can be used to model the observed
counts using a generalized linear model (with `edgeR`) or a general linear model
(with `limma`) and estimate a logFC and a p-value for the enrichment of each
variant betwen two conditions (or more generally, in association with any
predictor) compared to one or more WT sequences. Note that for this, at least
two replicates are required.

```{r}
## edgeR
edger_scores <- calculateRelativeFC(
  se = se_collapsed,
  design = model.matrix(~ Replicate + Condition,
                        data = colData(se_collapsed)),
  coef = 3, pseudocount = 1, WTrows = "f.0.NA",
  method = "edgeR")
head(edger_scores[order(edger_scores$PValue), , drop = FALSE])

## limma
limma_scores <- calculateRelativeFC(
  se = se_collapsed,
  design = model.matrix(~ Replicate + Condition,
                        data = colData(se_collapsed)),
  coef = 3, pseudocount = 1, WTrows = "f.0.NA",
  method = "limma")
head(limma_scores[order(limma_scores$P.Value), , drop = FALSE])
```

## Session info

This vignette was compiled on the following system:

```{r}
sessionInfo()
```

